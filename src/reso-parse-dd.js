var fs     = require('fs');
var path   = require('path');
var lodash = require('lodash');
var xml2js = require('xml2js');
var jsonld = require('jsonld');


var config = {
    parse:           {
        defaultSource: './data/reso_ddwiki_v15.xml',
        metaFields:    ['CertificationLevel'],
        classes:       true,
        properties:    true,
        // lookups aren't supported in this version.
        lookups:       false,
        ignoreValues:  ["<n/a>"]
    },
    header:          {
        comments: "# Generated by reso-parse-wiki\n",
        prefixes: {
            reso:   "https://yodata.io/reso/dd#",
            enum:   "https://yodata.io/reso/enum#",
            rdf:    "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
            rdfs:   "http://www.w3.org/2000/01/rdf-schema#",
            xsd:    "http://www.w3.org/2001/XMLSchema#",
            owl:    "http://www.w3.org/2002/07/owl#",
            dc:     "http://purl.org/dc/elements/1.1/",
            schema: "http://schema.org/",
            vs:     "http://www.w3.org/2003/06/sw-vocab-status/ns#"
        },
    },
    turtle:          {
        tabLength: 2,
        keyLength: 16,
    },
    addValueOptions: {
        allowDuplicate: false
    }
};

var _xmlToJson = function xmlToJson(pathToXmlSource, callback) {
    var parser = new xml2js.Parser();
    fs.readFile(pathToXmlSource, function (err, xmlData) {
        parser.parseString(xmlData, function (err, jsonData) {
            if (typeof callback === 'function') {
                return callback(err, jsonData);
            }
            console.dir(jsonData);
            console.log('done');
        });
    });
};

function Subject(id, type) {
    "use strict";
    Object.defineProperties(this, {
        id:   {value: id},
        type: {value: type}
    });
}

Subject.prototype.addValue = function addValue(property, value) {
    "use strict";
    if (typeof value === 'string') {

        if (config.parse.ignoreValues.includes(value)) {
            return this;
        }
        if (value.includes(':')) {
            if (value.startsWith('_:')) {
                jsonld.addValue(this, property, value, config.addValueOptions);
                return this;
            } else if (value.startsWith('http')) {
                jsonld.addValue(this, property, '<' + value + '>', config.addValueOptions);
                return this;
            } else if (config.header.prefixes.hasOwnProperty(value.substring(0, value.indexOf(":")))) {
                jsonld.addValue(this, property, value, config.addValueOptions);
                return this;
            }
        } else {
            jsonld.addValue(this, property, JSON.stringify(value), config.addValueOptions);
            return this;
        }
    } else if (Array.isArray(value)) {
        var sub = this;
        value.forEach(function (v) {
            sub.addValue(property, v);
        });
    }
    return this;
};

Subject.prototype.toTurtle = function toTurtle() {
    "use strict";
    var indent  = ' '.repeat(config.turtle.tabLength);
    var keys    = Object.keys(this).sort();
    var subject = this;
    var result  = [`${this.id} a ${this.type}`];
    keys.forEach(function (key) {
        var paddedKey = lodash.padEnd(key, config.turtle.keyLength);
        var value     = subject[key];
        result.push(indent + paddedKey + ' ' + value);
    });
    return result.join(' ;\n') + '\n.\n';
};

var parseResoWikiXML = function parseResoWikiXML(pathToXmlSource, options, callback) {
    "use strict";
    var sourcePath = pathToXmlSource || config.parse.defaultSource;
    _xmlToJson(sourcePath, function (err, jsonData) {
        if (typeof jsonData !== 'undefined') {
            var subjectIndex = [];

            var src  = path.parse(sourcePath);
            var dest = './ns/' + src.name + '.ttl';
            fs.openSync(dest, 'w+');

            var file        = jsonData['reso-ddwiki-export'];
            var fileMeta    = file.$;
            var copyright   = fileMeta['Copyright'].replace(/\n/g, '\n# ');
            var fileVersion = fileMeta['DDWikiVersion'];


            // file header

            fs.appendFileSync(dest, `# DDWikiVersion: ${fileVersion}\n#\n`);
            fs.appendFileSync(dest, `# ${copyright}\n\n`);
            fs.appendFileSync(dest, config.header.comments);

            // prefixes
            lodash.forEach(config.header.prefixes, function (uri, prefix) {
                fs.appendFileSync(dest, `@prefix ${prefix}: <${uri}> .\n`);
            });
            fs.appendFileSync(dest, '\n\n');

            // document info
            var doc = new Subject('<>', 'owl:Ontology')
                .addValue('dc:title', 'Real Estate Standards Vocabulary (RESO)')
                .addValue('dc:description', 'Mapping of the RESO Data Dictionary to RDF.')
                .addValue('rdfs:label', 'RESO Data Diction - RDF Vocabulary')
                .addValue('dc:publisher', 'http://www.reso.org')
                .addValue('dc:creator', "_:DaveDuran");

            var creator = new Subject('_:DaveDuran', 'schema:Person')
                .addValue('schema:name', 'Dave Duran')
                .addValue('schema:email', 'dave@yodata.io');


            fs.appendFileSync(dest, doc.toTurtle());
            fs.appendFileSync(dest, creator.toTurtle());


            // classes
            fs.appendFileSync(dest, '\n\n# classes\n\n');
            var resources = file['Resource'];
            resources.forEach(function (resource) {
                var classMeta    = resource.$;
                var classComment = classMeta['WikiPageTitle'];
                var classWikiURL = classMeta['WikiPageURL'];
                var classLabel   = classComment.slice(0, -9);
                var classCURI    = `reso:${classLabel}`;

                var subject = new Subject(classCURI, 'rdfs:Class')
                    .addValue('rdfs:label', classLabel)
                    .addValue('rdfs:comment', classComment)
                    .addValue('schema:sameAs', classWikiURL, 'IRI');

                fs.appendFileSync(dest, subject.toTurtle());
            });

            // properties
            if (config.parse.properties) {
                fs.appendFileSync(dest, "\n# properties \n\n");
                resources.forEach(function (resource) {
                    var classMeta    = resource.$;
                    var classComment = classMeta['WikiPageTitle'];
                    var classLabel   = classComment.slice(0, -9);
                    var classCURI    = `reso:${classLabel}`;

                    var resourceProperties = resource['Field'];
                    resourceProperties.forEach(
                        function (prop) {
                            var propMeta    = prop.$;
                            var propWikiURL = propMeta['WikiPageURL'];
                            var propLabel   = prop['StandardName'][0];
                            var propCURI    = `reso:${propLabel}`;

                            var subject = lodash.get(subjectIndex, propCURI);

                            if (typeof subject === 'undefined') {
                                subject                = new Subject(propCURI, 'rdf:Property');
                                subjectIndex[propCURI] = subject;
                            }

                            subject
                                .addValue('rdfs:label', propLabel)
                                .addValue('rdfs:domain', classCURI, 'id')
                                .addValue('schema:sameAs', propWikiURL);

                            if (prop.hasOwnProperty('Definition')) {
                                subject.addValue('rdfs:comment', prop['Definition']);
                            }

                            if (prop.hasOwnProperty('FieldDefinition')) {
                                subject.addValue('rdfs:comment', prop['FieldDefinition']);
                            }


                            var dataType = lodash.toLower(prop['SimpleDataType']);
                            switch (dataType) {
                                case 'string':
                                case 'boolean':
                                case 'date':
                                    subject.addValue('rdfs:range', `xsd:${dataType}`, 'id');
                                    break;
                                case 'timestamp':
                                    subject.addValue('rdfs:range', `xsd:dateTime`, 'id');
                                    break;
                                case 'number':
                                    subject.addValue('rdfs:range', 'xsd:decimal');
                                    break;
                                case 'string list, single':
                                case 'string list, multi':
                                    if (typeof prop['Lookup'] !== 'undefined') {
                                        var lookup = lodash.first(prop['Lookup']);
                                        if (typeof lookup === 'string' && lookup[0] === '<') {
                                            lookup = undefined;
                                        } else {
                                            lookup = lookup.substr(0, lookup.indexOf(' '));
                                        }
                                    }
                                    if (lookup) {
                                        subject.addValue('rdfs:range', `enum:${lookup}`);
                                    } else {
                                        subject.addValue('rdfs:range', 'xsd:string', 'id');
                                    }

                                    break;
                                default:
                                    throw new Error('unknown dataType' + dataType);
                            }

                            var elementStatus = lodash.toLower(prop['ElementStatus']);
                            switch (elementStatus) {
                                case 'active':
                                    subject.addValue('vs:term_status', 'stable');
                                    break;
                                case 'proposed':
                                    subject.addValue('vs:term_status', 'testing');
                                    break;
                                default:
                                    subject.addValue('reso:ElementStatus', elementStatus);
                            }

                            if (prop['PropertyTypes']) {
                                var propTypes = prop['PropertyTypes'][0]['Class'];
                                subject.addValue('reso:PropertyTypes', propTypes);
                            }

                            config.parse.metaFields.forEach(function (key) {
                                var value = prop[key];
                                if (typeof value !== 'undefined') {
                                    subject.addValue(`reso:${key}`, value);
                                }
                            });

                            fs.appendFileSync(dest, subject.toTurtle());
                        }
                    );

                });
            }

            /**
             *  parse lookups : not yet implemented.
             */
            if (config.parse.lookups) {
                // var lookups = file['LookupValues'][0]['LookupField'];
                // lookups.forEach(function (lookupField) {
                //     console.dir(lookupField);
                // });
            }
        }
        if (err) {
            return (typeof callback === 'function') ? callback(err) : console.error(err);
        }
    });
};

module.exports = {config, parseResoWikiXML};
